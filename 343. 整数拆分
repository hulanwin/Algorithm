343. 整数拆分
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。

示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。

说明: 你可以假设 n 不小于 2 且不大于 58。

通过观察，首先肯定可以明确，2 和 3 是没办法进行拆分的最小因子。同时，我们好像能看出来：
   只要把 n 尽可能的拆分成包含3的组合，就可以得到最大值。
   如果没办法拆成 3 的组合，就退一步拆成 2 的组合。
   对于 3 和 2 ，没办法再进行拆分。

根据分析，我们尝试使用贪心进行求解。因为一个数（假设为n）除以另一个数，总是包括整数部分（x）和余数部分（y）。那刚才也得到了，最优因子是3，所以我们需要让 n/3，这样的话，余数可能是 1,2 两种可能性。

如果余数是 1 ，刚才我们也分析过，对于 1 的拆分是没有意义的，所以我们退一步，将最后一次的 3 和 1 的拆分，用 2 和 2 代替。
如果余数是 2 ，那不消多说，直接乘以最后的 2 即可。


class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1, 0);
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 1;
        for(int i = 3; i <= n; i++){
            for(int j = 1; j < i; j++){
                int t = max(max(dp[j]*dp[i-j], max(dp[j]*(i-j), j*dp[i-j])), j*(i-j));
                dp[i] = max(dp[i], t);
            }
        }
        return dp[n];
    }
};